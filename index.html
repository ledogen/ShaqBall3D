<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>ShaqBall 3D</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; overflow: hidden; font-family: monospace; }
  canvas { display: block; }
  #title {
    position: fixed; top: 16px; left: 50%; transform: translateX(-50%);
    font-size: 28px; font-weight: 900; color: #fff; letter-spacing: 4px;
    text-shadow: 0 0 20px #0ff, 0 0 40px #0ff; pointer-events: none;
  }
  #controls {
    position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%);
    color: rgba(255,255,255,0.5); font-size: 12px; pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="title">SHAQBALL 3D</div>
<div id="controls">WASD tilt &nbsp;|&nbsp; â† â†’ â†‘ â†“ orbit camera &nbsp;|&nbsp; SPACE jump &nbsp;|&nbsp; R reset</div>
<div id="hud" style="position:fixed;top:16px;right:16px;font-family:monospace;font-size:13px;text-align:right;pointer-events:none;line-height:2;"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>

// â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const P = {
  mass: 1.0, radius: 0.5,
  gravity: 25,
  tiltSpeed: 80, tiltMax: 15, tiltReturn: 120,
  stageW: 10,   // half-width  â†’ total 20 units wide (X: -10 to +10)
  stageNear: -10, // Z start (near end)
  stageFar:   90, // Z end   (far end)
  startClear:  5, // obstacles/powerups start no closer than this Z
};
const I_BALL = 0.4 * P.mass * P.radius * P.radius;

// â”€â”€ BASE PHYSICS (reset target) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BASE = { radius: P.radius, gravity: P.gravity, jumpSpeed: 4.8 };

// â”€â”€ POWERUP STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const fx = { sizeUp: false, bouncyBall: false, speedUp: false, hasJetpack: false };
let   currentRadius = BASE.radius;
let   currentJump   = BASE.jumpSpeed;
let   bouncyMult    = 1.0;

// Jetpack fuel state
const JETPACK_MAX       = 1.0;   // full tank
const JETPACK_DRAIN     = 0.45;  // fuel/sec while burning
const JETPACK_THRUST    = 18;    // upward accel m/sÂ² while burning
const JETPACK_REFILL_DELAY = 2.0; // seconds after landing before refill starts
const JETPACK_REFILL_RATE  = 0.4; // fuel/sec when refilling
let jetpackFuel      = 0;
let jetpackLandTime  = -999; // timestamp of last landing

const hud = document.getElementById('hud');
const fuelMeter = document.createElement('div');
fuelMeter.style.cssText = 'position:fixed;bottom:40px;left:50%;transform:translateX(-50%);width:120px;display:none;';
fuelMeter.innerHTML = `
  <div style="color:#80ff80;font-family:monospace;font-size:11px;text-align:center;margin-bottom:3px;">ğŸš€ JETPACK</div>
  <div style="background:rgba(0,0,0,0.5);border:1px solid #80ff80;border-radius:3px;height:8px;overflow:hidden;">
    <div id="fuelBar" style="height:100%;background:#80ff80;width:100%;transition:none;"></div>
  </div>`;
document.body.appendChild(fuelMeter);
const fuelBar = document.getElementById('fuelBar');

function applyEffects() {
  currentRadius = BASE.radius * (fx.sizeUp ? 1.5 : 1);
  currentJump   = BASE.jumpSpeed * (fx.sizeUp ? 1.5 : 1);
  P.gravity     = BASE.gravity   * (fx.speedUp ? 1.8 : 1);
  bouncyMult    = fx.bouncyBall ? 1.6 : 1.0;
  ballMesh.scale.setScalar(currentRadius / BASE.radius);
  fuelMeter.style.display = fx.hasJetpack ? 'block' : 'none';
}

function resetEffects() {
  fx.sizeUp = false; fx.bouncyBall = false; fx.speedUp = false; fx.hasJetpack = false;
  jetpackFuel = 0; jetpackLandTime = -999;
  applyEffects();
}

function updateHUD() {
  const lines = [];
  if (fx.sizeUp)     lines.push('<span style="color:#f0c040">â¬† SIZE UP</span>');
  if (fx.bouncyBall) lines.push('<span style="color:#40e0ff">â— BOUNCY BALL</span>');
  if (fx.speedUp)    lines.push('<span style="color:#ff6040">âš¡ SPEED UP</span>');
  hud.innerHTML = lines.join('<br>');
  if (fx.hasJetpack) fuelBar.style.width = (jetpackFuel / JETPACK_MAX * 100) + '%';
}

// Powerup definitions
const POWERUP_DEFS = {
  sizeup:     { color: 0xf0c040, label: 'S', onPickup() { fx.sizeUp = true;  applyEffects(); } },
  bouncyball: { color: 0x40e0ff, label: 'B', onPickup() { fx.bouncyBall = true; applyEffects(); } },
  speedup:    { color: 0xff6040, label: '!', onPickup() { fx.speedUp = true; applyEffects(); } },
  jetpack:    { color: 0x80ff80, label: 'J', onPickup() { fx.hasJetpack = true; jetpackFuel = JETPACK_MAX; applyEffects(); } },
};

// Active powerup meshes in the scene (not in stageGroup â€” they don't tilt)
const powerupMeshes = [];

function spawnPowerups() {
  // Clear old
  powerupMeshes.forEach(m => stageGroup.remove(m));
  powerupMeshes.length = 0;

  const types = Object.keys(POWERUP_DEFS);
  const count = 4 + Math.floor(rng() * 4);
  for (let i = 0; i < count; i++) {
    const type = rngItem(types);
    const def  = POWERUP_DEFS[type];
    const geo  = new THREE.SphereGeometry(0.6, 12, 12);
    const mat  = new THREE.MeshStandardMaterial({ color: def.color, emissive: def.color, emissiveIntensity: 0.6, roughness: 0.3, metalness: 0.5 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(rngRange(-W+2, W-2), 1.5, rngRange(P.startClear, ZF-5));
    mesh.userData.powerupType = type;
    mesh.userData.collidable = false;
    mesh.castShadow = true;
    stageGroup.add(mesh);
    powerupMeshes.push(mesh);
  }
}


// â”€â”€ MATERIALS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MATERIALS = {
  default: {
    friction: 0.6, restitution: 0.55, rollingResist: 0.1,
    appearance: {
      color: 0xffffff, roughness: 0.8, metalness: 0.1,
      texture(ctx, s) {
        const q = s / 8;
        for (let i = 0; i < 8; i++) for (let j = 0; j < 8; j++) {
          ctx.fillStyle = (i+j)%2 ? '#6b3f1e' : '#8b5a2b';
          ctx.fillRect(i*q, j*q, q, q);
          ctx.strokeStyle = 'rgba(40,20,5,0.3)'; ctx.lineWidth = 1;
          ctx.strokeRect(i*q+.5, j*q+.5, q-1, q-1);
        }
      },
    },
  },
  wood: {
    friction: 0.6, restitution: 0.3, rollingResist: 0.016,
    appearance: {
      color: 0xc8a96e, roughness: 0.85, metalness: 0,
      texture(ctx, s) {
        ctx.fillStyle = '#c8a96e'; ctx.fillRect(0, 0, s, s);
        ctx.strokeStyle = 'rgba(90,55,20,0.18)'; ctx.lineWidth = 2;
        for (let y = 0; y < s; y += s/12) {
          ctx.beginPath(); ctx.moveTo(0, y);
          for (let x = 0; x < s; x += 4) ctx.lineTo(x, y + Math.sin((x+y)*0.08)*8);
          ctx.stroke();
        }
      },
    },
  },
  ice: {
    friction: 0.05, restitution: 0.1, rollingResist: 0.002,
    appearance: {
      color: 0xaadeff, roughness: 0.05, metalness: 0.4, transparent: false,
      texture(ctx, s) {
        ctx.fillStyle = '#cceeff'; ctx.fillRect(0, 0, s, s);
        ctx.strokeStyle = 'rgba(180,220,255,0.6)'; ctx.lineWidth = 1;
        for (let i = 0; i < 10; i++) {
          ctx.beginPath();
          let x = Math.random()*s, y = Math.random()*s; ctx.moveTo(x, y);
          for (let k = 0; k < 4; k++) { x += (Math.random()-.5)*s*.3; y += (Math.random()-.5)*s*.3; ctx.lineTo(x,y); }
          ctx.stroke();
        }
      },
    },
  },
  rubber: {
    friction: 0.9, restitution: 0.95, rollingResist: 0.04,
    appearance: {
      color: 0x222222, roughness: 0.95, metalness: 0,
      texture(ctx, s) {
        ctx.fillStyle = '#222'; ctx.fillRect(0, 0, s, s);
        ctx.strokeStyle = 'rgba(80,80,80,0.5)'; ctx.lineWidth = 1;
        const d = s/8;
        for (let i = -1; i < 9; i++) for (let j = -1; j < 9; j++) {
          const cx = i*d+(j%2)*d*.5, cy = j*d;
          ctx.beginPath(); ctx.moveTo(cx, cy-d*.4); ctx.lineTo(cx+d*.4, cy);
          ctx.lineTo(cx, cy+d*.4); ctx.lineTo(cx-d*.4, cy); ctx.closePath(); ctx.stroke();
        }
      },
    },
  },
  metal: {
    friction: 0.4, restitution: 0.5, rollingResist: 0.008,
    appearance: {
      color: 0x8899aa, roughness: 0.3, metalness: 0.9,
      texture(ctx, s) {
        for (let y = 0; y < s; y += 2) {
          const v = 136 + Math.floor(Math.random()*20-10);
          ctx.fillStyle = `rgb(${v},${v+8},${v+16})`; ctx.fillRect(0, y, s, 1);
        }
        ctx.fillStyle = 'rgba(60,70,80,0.6)';
        const sp = s/4;
        for (let i = 0; i < 4; i++) for (let j = 0; j < 4; j++) {
          ctx.beginPath(); ctx.arc(i*sp+sp/2, j*sp+sp/2, 4, 0, Math.PI*2); ctx.fill();
        }
      },
    },
  },
  concrete: {
    friction: 0.7, restitution: 0.2, rollingResist: 0.02,
    appearance: {
      color: 0x999999, roughness: 0.95, metalness: 0,
      texture(ctx, s) {
        ctx.fillStyle = '#999'; ctx.fillRect(0, 0, s, s);
        for (let i = 0; i < 3000; i++) {
          const v = Math.floor(Math.random()*60+120);
          ctx.fillStyle = `rgba(${v},${v},${v},0.3)`;
          ctx.fillRect(Math.random()*s, Math.random()*s, 2, 2);
        }
        ctx.strokeStyle = 'rgba(80,80,80,0.4)'; ctx.lineWidth = 2;
        [s/3, s*2/3].forEach(p => {
          ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,s); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(s,p); ctx.stroke();
        });
      },
    },
  },
  sand: {
    friction: 0.8, restitution: 0.05, rollingResist: 0.3,
    appearance: {
      color: 0xf0d875, roughness: 1.0, metalness: 0,
      texture(ctx, s) {
        ctx.fillStyle = '#f0d875'; ctx.fillRect(0, 0, s, s);
        for (let i = 0; i < 6000; i++) {
          const v = Math.floor(Math.random()*40);
          ctx.fillStyle = `rgba(${210+v},${190+v},${100+v*.5|0},0.4)`;
          ctx.fillRect(Math.random()*s, Math.random()*s, 1.5, 1.5);
        }
      },
    },
  },
  wall: {
    friction: 0.5, restitution: 0.3, rollingResist: 0.01,
    appearance: { color: 0x0088ff, roughness: 0.3, metalness: 0.6, transparent: true, opacity: 0.45 },
  },
};

// â”€â”€ THREE.JS SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('c'), antialias: true });
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a0a1a);
scene.fog = new THREE.Fog(0x0a0a1a, 40, 120);

const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 500);
camera.position.set(0, 20, 32);

window.addEventListener('resize', () => {
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
});

scene.add(new THREE.AmbientLight(0x334466, 1.5));
const sun = new THREE.DirectionalLight(0xffffff, 2.5);
sun.position.set(25, 50, 25);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
Object.assign(sun.shadow.camera, { near:1, far:400, left:-20, right:20, top:100, bottom:-20 });
scene.add(sun);
const fill = new THREE.PointLight(0x0088ff, 1.5, 80);
fill.position.set(-20, 15, -20);
scene.add(fill);

// â”€â”€ STAGE HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const stageGroup = new THREE.Group();
scene.add(stageGroup);

function buildThreeMat(matName, tileSize = 1) {
  const { appearance: a } = MATERIALS[matName] || MATERIALS.default;
  const p = { color: a.color ?? 0xffffff, roughness: a.roughness ?? 0.8, metalness: a.metalness ?? 0 };
  if (a.transparent) { p.transparent = true; p.opacity = a.opacity ?? 1; }
  if (a.texture) {
    const canvas = Object.assign(document.createElement('canvas'), { width: 512, height: 512 });
    a.texture(canvas.getContext('2d'), 512);
    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    p.map = tex;
  }
  const mat = new THREE.MeshStandardMaterial(p);
  if (p.map) mat.userData._tex = p.map;
  mat.userData._tileSize = tileSize;
  return mat;
}

function addToStage(geo, matName, { position = new THREE.Vector3(), rotation = new THREE.Euler(), tileSize = 1, castShadow = true, collidable = true } = {}) {
  const mat  = buildThreeMat(matName, tileSize);
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(position);
  mesh.rotation.copy(rotation);
  mesh.castShadow = castShadow;
  mesh.receiveShadow = true;
  mesh.userData.physicsMaterial = matName;
  mesh.userData.collidable = collidable;
  if (mat.userData._tex) {
    geo.computeBoundingBox();
    const { min, max } = geo.boundingBox;
    mat.userData._tex.repeat.set((max.x - min.x) / tileSize / 8, (max.z - min.z) / tileSize / 8);
  }
  stageGroup.add(mesh);
  return mesh;
}

// â”€â”€ BUILD STAGE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const V = (x,y,z) => new THREE.Vector3(x,y,z);
const E = (x,y,z) => new THREE.Euler(x,y,z);

const W  = P.stageW;                          // half-width  = 10
const ZN = P.stageNear;                       // near end    = -10
const ZF = P.stageFar;                        // far end     = 90
const stageLen = ZF - ZN;                     // total length = 100
const stageCtrZ = (ZN + ZF) / 2;             // center Z    = 40

// Permanent floor â€” added once, never cleared
addToStage(
  new THREE.PlaneGeometry(W*2, stageLen).applyMatrix4(new THREE.Matrix4().makeRotationX(-Math.PI/2)),
  'default',
  { position: V(0, 0, stageCtrZ) }
);

const rng = () => Math.random();
const rngRange = (a, b) => a + rng() * (b - a);
const rngItem = arr => arr[Math.floor(rng() * arr.length)];

// Random position within the corridor, respecting start clear zone
const rngPos = (xMargin = 1) => V(
  rngRange(-W + xMargin, W - xMargin),
  0,
  rngRange(P.startClear, ZF - 5)
);

const surfaceMats = ['wood', 'metal', 'concrete', 'ice', 'rubber', 'sand'];
const rampMats    = ['wood', 'metal', 'concrete'];
const bumperMats  = ['rubber', 'metal', 'concrete'];

function buildStage() {
  // Remove all children except the permanent floor
  stageGroup.children.slice(1).forEach(c => stageGroup.remove(c));

  // Sand/ice patches â€” capped to max 8 wide so there's always a gap to squeeze through
  const patchCount = 3 + Math.floor(rng() * 4);
  for (let i = 0; i < patchCount; i++) {
    const w   = rngRange(4, 8);
    const d   = rngRange(6, 18);
    const mat = rng() < 0.5 ? 'sand' : 'ice';
    const p   = rngPos(1);
    p.y = mat === 'sand' ? 0.05 : 0.08;
    addToStage(new THREE.BoxGeometry(w, mat === 'sand' ? 0.1 : 0.06, d), mat, { position: p });
  }

  // Ramps
  const rampCount = 2 + Math.floor(rng() * 3);
  for (let i = 0; i < rampCount; i++) {
    const w       = rngRange(4, W * 1.5);
    const d       = rngRange(6, 20);
    const tiltAmt = rngRange(0.1, 0.35) * (rng() < 0.5 ? 1 : -1);
    const axis    = rng() < 0.5 ? E(tiltAmt, 0, 0) : E(0, 0, tiltAmt);
    const p = rngPos(2); p.y = rngRange(0.5, 3);
    addToStage(new THREE.BoxGeometry(w, 0.5, d), rngItem(rampMats), { position: p, rotation: axis });
  }

  // Raised platforms
  const platCount = 1 + Math.floor(rng() * 3);
  for (let i = 0; i < platCount; i++) {
    const w = rngRange(4, W * 1.5), d = rngRange(5, 16), h = rngRange(0.5, 3);
    const p = rngPos(2); p.y = h / 2;
    addToStage(new THREE.BoxGeometry(w, h, d), rngItem(rampMats), { position: p });
  }

  // Bumper cylinders
  const bumperCount = 3 + Math.floor(rng() * 5);
  for (let i = 0; i < bumperCount; i++) {
    const r = rngRange(0.6, 1.8), h = rngRange(1.5, 4);
    const p = rngPos(2); p.y = h / 2;
    addToStage(new THREE.CylinderGeometry(r, r, h, 16), rngItem(bumperMats), { position: p });
  }

  // Box obstacles
  const boxCount = 3 + Math.floor(rng() * 4);
  for (let i = 0; i < boxCount; i++) {
    const sz = rngRange(1.5, 4);
    const p = rngPos(2); p.y = sz / 2;
    addToStage(new THREE.BoxGeometry(sz, sz, sz), rngItem(surfaceMats), { position: p });
  }

  // Cones
  const coneCount = 1 + Math.floor(rng() * 3);
  for (let i = 0; i < coneCount; i++) {
    const r = rngRange(1.5, 3.5), h = rngRange(2, 5);
    const p = rngPos(2); p.y = h / 2;
    addToStage(new THREE.ConeGeometry(r, h, 16), rngItem(rampMats), { position: p });
  }

  // Torus half-pipe (only if corridor is wide enough to make sense)
  if (rng() < 0.6) {
    const r = rngRange(2, 4);
    const p = rngPos(3); p.y = rngRange(1, 3);
    addToStage(new THREE.TorusGeometry(r, rngRange(0.5, 1), 8, 24, Math.PI), rngItem(rampMats), {
      position: p,
      rotation: E(Math.PI/2, rngRange(0, Math.PI*2), 0),
    });
  }
}

// â”€â”€ BALL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const ballMesh = new THREE.Mesh(
  new THREE.SphereGeometry(BASE.radius, 32, 32),
  new THREE.MeshStandardMaterial({ map: new THREE.TextureLoader().load('shaq.png'), roughness: 0.6, metalness: 0.1 })
);
ballMesh.castShadow = ballMesh.receiveShadow = true;
scene.add(ballMesh);

buildStage();
spawnPowerups();

// â”€â”€ PHYSICS STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let pos    = new THREE.Vector3(0, BASE.radius, 0);
let vel    = new THREE.Vector3();
let angVel = new THREE.Vector3();
let orient = new THREE.Quaternion();
let onFloor = false;
let tiltX = 0, tiltZ = 0;

// â”€â”€ CAMERA ORBIT STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let camAzimuth = 0;
let camPolar   = 0.85;
const CAM_DIST       = 22;
const CAM_AZ_SPEED   = 1.8;
const CAM_POL_DEFAULT = 0.85;
const CAM_POL_HIGH    = 0.15;
const CAM_POL_LOW     = 1.35;

// â”€â”€ INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Space') e.preventDefault();
  if (e.code === 'KeyR') reset();
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

function reset() {
  pos.set(0, BASE.radius, 0); vel.set(0,0,0); angVel.set(0,0,0);
  orient.identity(); tiltX = tiltZ = 0;
  resetEffects();
  buildStage();
  spawnPowerups();
}

// â”€â”€ COLLISION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const _A = new THREE.Vector3(), _B = new THREE.Vector3(), _C = new THREE.Vector3();
const _ab = new THREE.Vector3(), _ac = new THREE.Vector3();

function closestPointOnTri(P, A, B, C, out) {
  _ab.copy(B).sub(A); _ac.copy(C).sub(A);
  const ap = new THREE.Vector3().copy(P).sub(A);
  const d1 = _ab.dot(ap), d2 = _ac.dot(ap);
  if (d1 <= 0 && d2 <= 0) { out.copy(A); return; }
  const bp = new THREE.Vector3().copy(P).sub(B);
  const d3 = _ab.dot(bp), d4 = _ac.dot(bp);
  if (d3 >= 0 && d4 <= d3) { out.copy(B); return; }
  const cp = new THREE.Vector3().copy(P).sub(C);
  const d5 = _ab.dot(cp), d6 = _ac.dot(cp);
  if (d6 >= 0 && d5 <= d6) { out.copy(C); return; }
  const vc = d1*d4 - d3*d2;
  if (vc <= 0 && d1 >= 0 && d3 <= 0) { out.copy(A).addScaledVector(_ab, d1/(d1-d3)); return; }
  const vb = d5*d2 - d1*d6;
  if (vb <= 0 && d2 >= 0 && d6 <= 0) { out.copy(A).addScaledVector(_ac, d2/(d2-d6)); return; }
  const va = d3*d6 - d5*d4;
  if (va <= 0 && (d4-d3) >= 0 && (d5-d6) >= 0) {
    out.copy(B).addScaledVector(new THREE.Vector3().copy(C).sub(B), (d4-d3)/((d4-d3)+(d5-d6))); return;
  }
  const f = 1/(va+vb+vc);
  out.copy(A).addScaledVector(_ab, vb*f).addScaledVector(_ac, vc*f);
}

function sphereMeshCollision(center, radius, mesh) {
  const { attributes: { position: pos }, index } = mesh.geometry;
  const mw = mesh.matrixWorld;
  const triCount = index ? index.count/3 : pos.count/3;
  const cp = new THREE.Vector3();
  let bestDepth = 0, bestNormal = null;

  for (let i = 0; i < triCount; i++) {
    const i0 = index ? index.getX(i*3)   : i*3;
    const i1 = index ? index.getX(i*3+1) : i*3+1;
    const i2 = index ? index.getX(i*3+2) : i*3+2;
    _A.fromBufferAttribute(pos, i0).applyMatrix4(mw);
    _B.fromBufferAttribute(pos, i1).applyMatrix4(mw);
    _C.fromBufferAttribute(pos, i2).applyMatrix4(mw);
    closestPointOnTri(center, _A, _B, _C, cp);
    const diff = new THREE.Vector3().copy(center).sub(cp);
    const dist = diff.length();
    if (dist > 1e-10 && dist < radius && radius-dist > bestDepth) {
      bestDepth = radius - dist;
      bestNormal = diff.divideScalar(dist);
    }
  }
  return bestNormal ? { normal: bestNormal, depth: bestDepth } : null;
}

// â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const DEG = Math.PI / 180;
let prevTime = performance.now();

function animate() {
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt  = Math.min((now - prevTime) / 1000, 0.05);
  prevTime  = now;

  // Tilt â€” WASD in camera-relative space
  const ts = P.tiltSpeed * DEG * dt, tr = P.tiltReturn * DEG * dt, tm = P.tiltMax * DEG;
  const pX = keys['KeyW'] || keys['KeyS'];
  const pZ = keys['KeyA'] || keys['KeyD'];
  if (keys['KeyW']) tiltX = Math.max(tiltX - ts, -tm);
  if (keys['KeyS']) tiltX = Math.min(tiltX + ts,  tm);
  if (keys['KeyA']) tiltZ = Math.min(tiltZ + ts,  tm);
  if (keys['KeyD']) tiltZ = Math.max(tiltZ - ts, -tm);
  if (!pX) tiltX = Math.abs(tiltX) <= tr ? 0 : tiltX - Math.sign(tiltX) * tr;
  if (!pZ) tiltZ = Math.abs(tiltZ) <= tr ? 0 : tiltZ - Math.sign(tiltZ) * tr;

  // Rotate tilt vector by camera azimuth so W always tilts away from camera
  const ca = Math.cos(camAzimuth), sa = Math.sin(camAzimuth);
  const worldTiltX =  tiltX * ca + tiltZ * sa;
  const worldTiltZ = -tiltX * sa + tiltZ * ca;

  // Camera orbit â€” arrow keys; up/down snap to preset polar angles
  if (keys['ArrowLeft'])  camAzimuth += CAM_AZ_SPEED * dt;
  if (keys['ArrowRight']) camAzimuth -= CAM_AZ_SPEED * dt;
  const targetPolar = keys['ArrowDown'] ? CAM_POL_HIGH : keys['ArrowUp'] ? CAM_POL_LOW : CAM_POL_DEFAULT;
  camPolar += (targetPolar - camPolar) * Math.min(1, 12 * dt);

  // Stage pivot around ball contact point
  const stageQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(worldTiltX, 0, worldTiltZ, 'XZY'));
  const pivot = new THREE.Vector3(pos.x, 0, pos.z);
  stageGroup.position.copy(pivot).sub(pivot.clone().applyQuaternion(stageQuat));
  stageGroup.setRotationFromQuaternion(stageQuat);

  // Physics
  const grav = new THREE.Vector3(0, -P.gravity, 0);
  vel.addScaledVector(grav, dt);
  pos.addScaledVector(vel, dt);

  // Jump / jetpack
  const wasOnFloor = onFloor;
  if (keys['Space']) {
    if (onFloor) {
      vel.y += currentJump; onFloor = false;
    } else if (fx.hasJetpack && jetpackFuel > 0) {
      vel.y += JETPACK_THRUST * dt;
      jetpackFuel = Math.max(0, jetpackFuel - JETPACK_DRAIN * dt);
      updateHUD();
    }
  }

  // Track landing moment for refill delay
  if (onFloor && !wasOnFloor) jetpackLandTime = now / 1000;

  // Refill after 2s on ground
  if (fx.hasJetpack && onFloor && jetpackFuel < JETPACK_MAX) {
    if ((now / 1000 - jetpackLandTime) >= JETPACK_REFILL_DELAY) {
      jetpackFuel = Math.min(JETPACK_MAX, jetpackFuel + JETPACK_REFILL_RATE * dt);
      updateHUD();
    }
  }

  // Powerup pickup (compare world positions since powerups are in stageGroup)
  stageGroup.updateMatrixWorld(true);
  for (let i = powerupMeshes.length - 1; i >= 0; i--) {
    const m = powerupMeshes[i];
    const worldPos = new THREE.Vector3().setFromMatrixPosition(m.matrixWorld);
    if (pos.distanceTo(worldPos) < currentRadius + 0.8) {
      POWERUP_DEFS[m.userData.powerupType].onPickup();
      stageGroup.remove(m);
      powerupMeshes.splice(i, 1);
      updateHUD();
    }
  }

  // Bob powerup meshes in local stage space
  powerupMeshes.forEach((m, idx) => {
    m.position.y = 1.5 + Math.sin(now * 0.002 + idx * 1.3) * 0.3;
    m.rotation.y += dt * 1.5;
  });

  // Collision
  stageGroup.updateMatrixWorld(true);
  onFloor = false;
  stageGroup.traverse(child => {
    if (!child.isMesh || child.userData.collidable === false) return;
    const hit = sphereMeshCollision(pos, currentRadius, child);
    if (!hit) return;
    const { normal: n, depth } = hit;
    const phys = MATERIALS[child.userData.physicsMaterial] || MATERIALS.default;
    const restitution = Math.min(phys.restitution * bouncyMult, 0.99);

    pos.addScaledVector(n, depth);
    const vn = vel.dot(n);
    if (vn < 0) {
      vel.addScaledVector(n, -vn * (1 + restitution));
      if (vel.dot(n) < 0.4) vel.addScaledVector(n, -vel.dot(n));
    }
    onFloor = true;

    // Friction
    const r = n.clone().multiplyScalar(-currentRadius);
    const vSlip = vel.clone().add(new THREE.Vector3().crossVectors(angVel, r))
      .addScaledVector(n, -vel.clone().add(new THREE.Vector3().crossVectors(angVel, r)).dot(n));
    const slipSpeed = vSlip.length();
    if (slipSpeed > 1e-5) {
      const I_cur = 0.4 * P.mass * currentRadius * currentRadius;
      const sd   = vSlip.clone().divideScalar(slipSpeed);
      const Fn   = P.mass * Math.abs(grav.dot(n));
      const mEff = 1 / (1/P.mass + new THREE.Vector3().crossVectors(r, sd).lengthSq() / I_cur);
      const imp  = sd.multiplyScalar(-Math.min(slipSpeed * mEff, phys.friction * Fn * dt));
      vel.addScaledVector(imp, 1/P.mass);
      angVel.addScaledVector(new THREE.Vector3().crossVectors(r, imp), 1/I_cur);
    }

    // Rolling resistance
    const I_cur2 = 0.4 * P.mass * currentRadius * currentRadius;
    const wSpeed = angVel.length();
    if (wSpeed > 1e-6) {
      const dw = Math.min(phys.rollingResist * P.mass * Math.abs(grav.dot(n)) * currentRadius * dt / I_cur2, wSpeed);
      angVel.multiplyScalar(1 - dw / wSpeed);
    }
  });

  if (pos.y < -15) { reset(); return; }

  // Orientation
  const wLen = angVel.length();
  if (wLen > 1e-10) {
    orient.premultiply(new THREE.Quaternion().setFromAxisAngle(angVel.clone().divideScalar(wLen), wLen * dt));
    orient.normalize();
  }

  // Update meshes & camera
  ballMesh.position.copy(pos);
  ballMesh.setRotationFromQuaternion(orient);

  // Spherical orbit camera around ball
  const camX = pos.x + CAM_DIST * Math.sin(camPolar) * Math.sin(camAzimuth);
  const camY = pos.y + CAM_DIST * Math.cos(camPolar);
  const camZ = pos.z + CAM_DIST * Math.sin(camPolar) * Math.cos(camAzimuth);
  camera.position.lerp(new THREE.Vector3(camX, camY, camZ), 0.08);
  camera.lookAt(pos);
  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>