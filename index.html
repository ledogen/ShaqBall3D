<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2575.7">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
  </style>
</head>
<body>
<p class="p1">&lt;!DOCTYPE html&gt;</p>
<p class="p1">&lt;html lang="en"&gt;</p>
<p class="p1">&lt;head&gt;</p>
<p class="p1">&lt;meta charset="UTF-8"&gt;</p>
<p class="p1">&lt;title&gt;ShaqBall 3D&lt;/title&gt;</p>
<p class="p1">&lt;style&gt;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>* { margin: 0; padding: 0; box-sizing: border-box; }</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>body { background: #000; overflow: hidden; font-family: monospace; }</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>canvas { display: block; }</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>#title {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>position: fixed; top: 16px; left: 50%; transform: translateX(-50%);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>font-size: 28px; font-weight: 900; color: #fff; letter-spacing: 4px;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>text-shadow: 0 0 20px #0ff, 0 0 40px #0ff; pointer-events: none;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>#controls {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>color: rgba(255,255,255,0.5); font-size: 12px; pointer-events: none;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p1">&lt;/style&gt;</p>
<p class="p1">&lt;/head&gt;</p>
<p class="p1">&lt;body&gt;</p>
<p class="p1">&lt;canvas id="c"&gt;&lt;/canvas&gt;</p>
<p class="p1">&lt;div id="title"&gt;SHAQBALL 3D&lt;/div&gt;</p>
<p class="p1">&lt;div id="controls"&gt;WASD tilt &amp;nbsp;|&amp;nbsp; â† â†’ â†‘ â†“ orbit camera &amp;nbsp;|&amp;nbsp; SPACE jump &amp;nbsp;|&amp;nbsp; R reset&lt;/div&gt;</p>
<p class="p1">&lt;div id="hud" style="position:fixed;top:16px;right:16px;font-family:monospace;font-size:13px;text-align:right;pointer-events:none;line-height:2;"&gt;&lt;/div&gt;</p>
<p class="p2"><br></p>
<p class="p1">&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"&gt;&lt;/script&gt;</p>
<p class="p1">&lt;script&gt;</p>
<p class="p2"><br></p>
<p class="p1">// â”€â”€ CONFIG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</p>
<p class="p1">const P = {</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>mass: 1.0, radius: 0.5,</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>gravity: 25,</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>tiltSpeed: 80, tiltMax: 15, tiltReturn: 120,</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>stageW: 10, <span class="Apple-converted-space">Â  </span>// half-width<span class="Apple-converted-space">Â  </span>â†’ total 20 units wide (X: -10 to +10)</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>stageNear: -10, // Z start (near end)</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>stageFar: <span class="Apple-converted-space">Â  </span>90, // Z end <span class="Apple-converted-space">Â  </span>(far end)</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>startClear:<span class="Apple-converted-space">Â  </span>5, // obstacles/powerups start no closer than this Z</p>
<p class="p1">};</p>
<p class="p1">const I_BALL = 0.4 * P.mass * P.radius * P.radius;</p>
<p class="p2"><br></p>
<p class="p1">// â”€â”€ BASE PHYSICS (reset target) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</p>
<p class="p1">const BASE = { radius: P.radius, gravity: P.gravity, jumpSpeed: 4.8 };</p>
<p class="p2"><br></p>
<p class="p1">// â”€â”€ POWERUP STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</p>
<p class="p1">const fx = { sizeUp: false, bouncyBall: false, speedUp: false, hasJetpack: false };</p>
<p class="p1">let <span class="Apple-converted-space">Â  </span>currentRadius = BASE.radius;</p>
<p class="p1">let <span class="Apple-converted-space">Â  </span>currentJump <span class="Apple-converted-space">Â  </span>= BASE.jumpSpeed;</p>
<p class="p1">let <span class="Apple-converted-space">Â  </span>bouncyMult<span class="Apple-converted-space">Â  Â  </span>= 1.0;</p>
<p class="p2"><br></p>
<p class="p1">// Jetpack fuel state</p>
<p class="p1">const JETPACK_MAX <span class="Apple-converted-space">Â  Â  Â  </span>= 1.0; <span class="Apple-converted-space">Â  </span>// full tank</p>
<p class="p1">const JETPACK_DRAIN <span class="Apple-converted-space">Â  Â  </span>= 0.45;<span class="Apple-converted-space">Â  </span>// fuel/sec while burning</p>
<p class="p1">const JETPACK_THRUST<span class="Apple-converted-space">Â  Â  </span>= 18;<span class="Apple-converted-space">Â  Â  </span>// upward accel m/sÂ² while burning</p>
<p class="p1">const JETPACK_REFILL_DELAY = 2.0; // seconds after landing before refill starts</p>
<p class="p1">const JETPACK_REFILL_RATE<span class="Apple-converted-space">Â  </span>= 0.4; // fuel/sec when refilling</p>
<p class="p1">let jetpackFuel<span class="Apple-converted-space">Â  Â  Â  </span>= 0;</p>
<p class="p1">let jetpackLandTime<span class="Apple-converted-space">Â  </span>= -999; // timestamp of last landing</p>
<p class="p2"><br></p>
<p class="p1">const hud = document.getElementById('hud');</p>
<p class="p1">const fuelMeter = document.createElement('div');</p>
<p class="p1">fuelMeter.style.cssText = 'position:fixed;bottom:40px;left:50%;transform:translateX(-50%);width:120px;display:none;';</p>
<p class="p1">fuelMeter.innerHTML = `</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>&lt;div style="color:#80ff80;font-family:monospace;font-size:11px;text-align:center;margin-bottom:3px;"&gt;ğŸš€ JETPACK&lt;/div&gt;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>&lt;div style="background:rgba(0,0,0,0.5);border:1px solid #80ff80;border-radius:3px;height:8px;overflow:hidden;"&gt;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>&lt;div id="fuelBar" style="height:100%;background:#80ff80;width:100%;transition:none;"&gt;&lt;/div&gt;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>&lt;/div&gt;`;</p>
<p class="p1">document.body.appendChild(fuelMeter);</p>
<p class="p1">const fuelBar = document.getElementById('fuelBar');</p>
<p class="p2"><br></p>
<p class="p1">function applyEffects() {</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>currentRadius = BASE.radius * (fx.sizeUp ? 1.5 : 1);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>currentJump <span class="Apple-converted-space">Â  </span>= BASE.jumpSpeed * (fx.sizeUp ? 1.5 : 1);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>P.gravity <span class="Apple-converted-space">Â  Â  </span>= BASE.gravity <span class="Apple-converted-space">Â  </span>* (fx.speedUp ? 1.8 : 1);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>bouncyMult<span class="Apple-converted-space">Â  Â  </span>= fx.bouncyBall ? 1.6 : 1.0;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>ballMesh.scale.setScalar(currentRadius / BASE.radius);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>fuelMeter.style.display = fx.hasJetpack ? 'block' : 'none';</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">function resetEffects() {</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>fx.sizeUp = false; fx.bouncyBall = false; fx.speedUp = false; fx.hasJetpack = false;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>jetpackFuel = 0; jetpackLandTime = -999;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>applyEffects();</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">function updateHUD() {</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const lines = [];</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (fx.sizeUp) <span class="Apple-converted-space">Â  Â  </span>lines.push('&lt;span style="color:#f0c040"&gt;â¬† SIZE UP&lt;/span&gt;');</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (fx.bouncyBall) lines.push('&lt;span style="color:#40e0ff"&gt;â— BOUNCY BALL&lt;/span&gt;');</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (fx.speedUp)<span class="Apple-converted-space">Â  Â  </span>lines.push('&lt;span style="color:#ff6040"&gt;âš¡ SPEED UP&lt;/span&gt;');</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>hud.innerHTML = lines.join('&lt;br&gt;');</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (fx.hasJetpack) fuelBar.style.width = (jetpackFuel / JETPACK_MAX * 100) + '%';</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">// Powerup definitions</p>
<p class="p1">const POWERUP_DEFS = {</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>sizeup: <span class="Apple-converted-space">Â  Â  </span>{ color: 0xf0c040, label: 'S', onPickup() { fx.sizeUp = true;<span class="Apple-converted-space">Â  </span>applyEffects(); } },</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>bouncyball: { color: 0x40e0ff, label: 'B', onPickup() { fx.bouncyBall = true; applyEffects(); } },</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>speedup:<span class="Apple-converted-space">Â  Â  </span>{ color: 0xff6040, label: '!', onPickup() { fx.speedUp = true; applyEffects(); } },</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>jetpack:<span class="Apple-converted-space">Â  Â  </span>{ color: 0x80ff80, label: 'J', onPickup() { fx.hasJetpack = true; jetpackFuel = JETPACK_MAX; applyEffects(); } },</p>
<p class="p1">};</p>
<p class="p2"><br></p>
<p class="p1">// Active powerup meshes in the scene (not in stageGroup â€” they don't tilt)</p>
<p class="p1">const powerupMeshes = [];</p>
<p class="p2"><br></p>
<p class="p1">function spawnPowerups() {</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Clear old</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>powerupMeshes.forEach(m =&gt; stageGroup.remove(m));</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>powerupMeshes.length = 0;</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const types = Object.keys(POWERUP_DEFS);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const count = 4 + Math.floor(rng() * 4);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>for (let i = 0; i &lt; count; i++) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const type = rngItem(types);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const def<span class="Apple-converted-space">Â  </span>= POWERUP_DEFS[type];</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const geo<span class="Apple-converted-space">Â  </span>= new THREE.SphereGeometry(0.6, 12, 12);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const mat<span class="Apple-converted-space">Â  </span>= new THREE.MeshStandardMaterial({ color: def.color, emissive: def.color, emissiveIntensity: 0.6, roughness: 0.3, metalness: 0.5 });</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const mesh = new THREE.Mesh(geo, mat);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>mesh.position.set(rngRange(-W+2, W-2), 1.5, rngRange(P.startClear, ZF-5));</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>mesh.userData.powerupType = type;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>mesh.userData.collidable = false;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>mesh.castShadow = true;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>stageGroup.add(mesh);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>powerupMeshes.push(mesh);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p2"><br></p>
<p class="p1">// â”€â”€ MATERIALS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</p>
<p class="p1">const MATERIALS = {</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>default: {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>friction: 0.6, restitution: 0.55, rollingResist: 0.1,</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>appearance: {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>color: 0xffffff, roughness: 0.8, metalness: 0.1,</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>texture(ctx, s) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>const q = s / 8;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>for (let i = 0; i &lt; 8; i++) for (let j = 0; j &lt; 8; j++) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.fillStyle = (i+j)%2 ? '#6b3f1e' : '#8b5a2b';</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.fillRect(i*q, j*q, q, q);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.strokeStyle = 'rgba(40,20,5,0.3)'; ctx.lineWidth = 1;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.strokeRect(i*q+.5, j*q+.5, q-1, q-1);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>wood: {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>friction: 0.6, restitution: 0.3, rollingResist: 0.016,</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>appearance: {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>color: 0xc8a96e, roughness: 0.85, metalness: 0,</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>texture(ctx, s) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>ctx.fillStyle = '#c8a96e'; ctx.fillRect(0, 0, s, s);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>ctx.strokeStyle = 'rgba(90,55,20,0.18)'; ctx.lineWidth = 2;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>for (let y = 0; y &lt; s; y += s/12) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.beginPath(); ctx.moveTo(0, y);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>for (let x = 0; x &lt; s; x += 4) ctx.lineTo(x, y + Math.sin((x+y)*0.08)*8);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.stroke();</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>ice: {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>friction: 0.05, restitution: 0.1, rollingResist: 0.002,</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>appearance: {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>color: 0xaadeff, roughness: 0.05, metalness: 0.4, transparent: false,</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>texture(ctx, s) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>ctx.fillStyle = '#cceeff'; ctx.fillRect(0, 0, s, s);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>ctx.strokeStyle = 'rgba(180,220,255,0.6)'; ctx.lineWidth = 1;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>for (let i = 0; i &lt; 10; i++) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.beginPath();</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>let x = Math.random()*s, y = Math.random()*s; ctx.moveTo(x, y);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>for (let k = 0; k &lt; 4; k++) { x += (Math.random()-.5)*s*.3; y += (Math.random()-.5)*s*.3; ctx.lineTo(x,y); }</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.stroke();</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>rubber: {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>friction: 0.9, restitution: 0.95, rollingResist: 0.04,</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>appearance: {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>color: 0x222222, roughness: 0.95, metalness: 0,</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>texture(ctx, s) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>ctx.fillStyle = '#222'; ctx.fillRect(0, 0, s, s);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>ctx.strokeStyle = 'rgba(80,80,80,0.5)'; ctx.lineWidth = 1;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>const d = s/8;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>for (let i = -1; i &lt; 9; i++) for (let j = -1; j &lt; 9; j++) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>const cx = i*d+(j%2)*d*.5, cy = j*d;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.beginPath(); ctx.moveTo(cx, cy-d*.4); ctx.lineTo(cx+d*.4, cy);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.lineTo(cx, cy+d*.4); ctx.lineTo(cx-d*.4, cy); ctx.closePath(); ctx.stroke();</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>metal: {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>friction: 0.4, restitution: 0.5, rollingResist: 0.008,</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>appearance: {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>color: 0x8899aa, roughness: 0.3, metalness: 0.9,</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>texture(ctx, s) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>for (let y = 0; y &lt; s; y += 2) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>const v = 136 + Math.floor(Math.random()*20-10);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.fillStyle = `rgb(${v},${v+8},${v+16})`; ctx.fillRect(0, y, s, 1);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>ctx.fillStyle = 'rgba(60,70,80,0.6)';</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>const sp = s/4;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>for (let i = 0; i &lt; 4; i++) for (let j = 0; j &lt; 4; j++) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.beginPath(); ctx.arc(i*sp+sp/2, j*sp+sp/2, 4, 0, Math.PI*2); ctx.fill();</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>concrete: {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>friction: 0.7, restitution: 0.2, rollingResist: 0.02,</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>appearance: {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>color: 0x999999, roughness: 0.95, metalness: 0,</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>texture(ctx, s) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>ctx.fillStyle = '#999'; ctx.fillRect(0, 0, s, s);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>for (let i = 0; i &lt; 3000; i++) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>const v = Math.floor(Math.random()*60+120);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.fillStyle = `rgba(${v},${v},${v},0.3)`;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.fillRect(Math.random()*s, Math.random()*s, 2, 2);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>ctx.strokeStyle = 'rgba(80,80,80,0.4)'; ctx.lineWidth = 2;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>[s/3, s*2/3].forEach(p =&gt; {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,s); ctx.stroke();</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(s,p); ctx.stroke();</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>});</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>sand: {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>friction: 0.8, restitution: 0.05, rollingResist: 0.3,</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>appearance: {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>color: 0xf0d875, roughness: 1.0, metalness: 0,</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>texture(ctx, s) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>ctx.fillStyle = '#f0d875'; ctx.fillRect(0, 0, s, s);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>for (let i = 0; i &lt; 6000; i++) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>const v = Math.floor(Math.random()*40);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.fillStyle = `rgba(${210+v},${190+v},${100+v*.5|0},0.4)`;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  Â  </span>ctx.fillRect(Math.random()*s, Math.random()*s, 1.5, 1.5);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>},</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>wall: {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>friction: 0.5, restitution: 0.3, rollingResist: 0.01,</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>appearance: { color: 0x0088ff, roughness: 0.3, metalness: 0.6, transparent: true, opacity: 0.45 },</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>},</p>
<p class="p1">};</p>
<p class="p2"><br></p>
<p class="p1">// â”€â”€ THREE.JS SETUP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</p>
<p class="p1">const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('c'), antialias: true });</p>
<p class="p1">renderer.setPixelRatio(devicePixelRatio);</p>
<p class="p1">renderer.setSize(innerWidth, innerHeight);</p>
<p class="p1">renderer.shadowMap.enabled = true;</p>
<p class="p1">renderer.shadowMap.type = THREE.PCFSoftShadowMap;</p>
<p class="p2"><br></p>
<p class="p1">const scene = new THREE.Scene();</p>
<p class="p1">scene.background = new THREE.Color(0x0a0a1a);</p>
<p class="p1">scene.fog = new THREE.Fog(0x0a0a1a, 40, 120);</p>
<p class="p2"><br></p>
<p class="p1">const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.1, 500);</p>
<p class="p1">camera.position.set(0, 20, 32);</p>
<p class="p2"><br></p>
<p class="p1">window.addEventListener('resize', () =&gt; {</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>renderer.setSize(innerWidth, innerHeight);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>camera.aspect = innerWidth / innerHeight;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>camera.updateProjectionMatrix();</p>
<p class="p1">});</p>
<p class="p2"><br></p>
<p class="p1">scene.add(new THREE.AmbientLight(0x334466, 1.5));</p>
<p class="p1">const sun = new THREE.DirectionalLight(0xffffff, 2.5);</p>
<p class="p1">sun.position.set(25, 50, 25);</p>
<p class="p1">sun.castShadow = true;</p>
<p class="p1">sun.shadow.mapSize.set(2048, 2048);</p>
<p class="p1">Object.assign(sun.shadow.camera, { near:1, far:400, left:-20, right:20, top:100, bottom:-20 });</p>
<p class="p1">scene.add(sun);</p>
<p class="p1">const fill = new THREE.PointLight(0x0088ff, 1.5, 80);</p>
<p class="p1">fill.position.set(-20, 15, -20);</p>
<p class="p1">scene.add(fill);</p>
<p class="p2"><br></p>
<p class="p1">// â”€â”€ STAGE HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</p>
<p class="p1">const stageGroup = new THREE.Group();</p>
<p class="p1">scene.add(stageGroup);</p>
<p class="p2"><br></p>
<p class="p1">function buildThreeMat(matName, tileSize = 1) {</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const { appearance: a } = MATERIALS[matName] || MATERIALS.default;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const p = { color: a.color ?? 0xffffff, roughness: a.roughness ?? 0.8, metalness: a.metalness ?? 0 };</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (a.transparent) { p.transparent = true; p.opacity = a.opacity ?? 1; }</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (a.texture) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const canvas = Object.assign(document.createElement('canvas'), { width: 512, height: 512 });</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>a.texture(canvas.getContext('2d'), 512);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const tex = new THREE.CanvasTexture(canvas);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>tex.wrapS = tex.wrapT = THREE.RepeatWrapping;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>p.map = tex;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const mat = new THREE.MeshStandardMaterial(p);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (p.map) mat.userData._tex = p.map;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>mat.userData._tileSize = tileSize;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>return mat;</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">function addToStage(geo, matName, { position = new THREE.Vector3(), rotation = new THREE.Euler(), tileSize = 1, castShadow = true, collidable = true } = {}) {</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const mat<span class="Apple-converted-space">Â  </span>= buildThreeMat(matName, tileSize);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const mesh = new THREE.Mesh(geo, mat);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>mesh.position.copy(position);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>mesh.rotation.copy(rotation);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>mesh.castShadow = castShadow;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>mesh.receiveShadow = true;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>mesh.userData.physicsMaterial = matName;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>mesh.userData.collidable = collidable;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (mat.userData._tex) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>geo.computeBoundingBox();</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const { min, max } = geo.boundingBox;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>mat.userData._tex.repeat.set((max.x - min.x) / tileSize / 8, (max.z - min.z) / tileSize / 8);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>stageGroup.add(mesh);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>return mesh;</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">// â”€â”€ BUILD STAGE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</p>
<p class="p1">const V = (x,y,z) =&gt; new THREE.Vector3(x,y,z);</p>
<p class="p1">const E = (x,y,z) =&gt; new THREE.Euler(x,y,z);</p>
<p class="p2"><br></p>
<p class="p1">const W<span class="Apple-converted-space">Â  </span>= P.stageW;<span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </span>// half-width<span class="Apple-converted-space">Â  </span>= 10</p>
<p class="p1">const ZN = P.stageNear; <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </span>// near end<span class="Apple-converted-space">Â  Â  </span>= -10</p>
<p class="p1">const ZF = P.stageFar;<span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </span>// far end <span class="Apple-converted-space">Â  Â  </span>= 90</p>
<p class="p1">const stageLen = ZF - ZN; <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </span>// total length = 100</p>
<p class="p1">const stageCtrZ = (ZN + ZF) / 2; <span class="Apple-converted-space">Â  Â  Â  Â  Â  Â  </span>// center Z<span class="Apple-converted-space">Â  Â  </span>= 40</p>
<p class="p2"><br></p>
<p class="p1">// Permanent floor â€” added once, never cleared</p>
<p class="p1">addToStage(</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>new THREE.PlaneGeometry(W*2, stageLen).applyMatrix4(new THREE.Matrix4().makeRotationX(-Math.PI/2)),</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>'default',</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>{ position: V(0, 0, stageCtrZ) }</p>
<p class="p1">);</p>
<p class="p2"><br></p>
<p class="p1">const rng = () =&gt; Math.random();</p>
<p class="p1">const rngRange = (a, b) =&gt; a + rng() * (b - a);</p>
<p class="p1">const rngItem = arr =&gt; arr[Math.floor(rng() * arr.length)];</p>
<p class="p2"><br></p>
<p class="p1">// Random position within the corridor, respecting start clear zone</p>
<p class="p1">const rngPos = (xMargin = 1) =&gt; V(</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>rngRange(-W + xMargin, W - xMargin),</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>0,</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>rngRange(P.startClear, ZF - 5)</p>
<p class="p1">);</p>
<p class="p2"><br></p>
<p class="p1">const surfaceMats = ['wood', 'metal', 'concrete', 'ice', 'rubber', 'sand'];</p>
<p class="p1">const rampMats<span class="Apple-converted-space">Â  Â  </span>= ['wood', 'metal', 'concrete'];</p>
<p class="p1">const bumperMats<span class="Apple-converted-space">Â  </span>= ['rubber', 'metal', 'concrete'];</p>
<p class="p2"><br></p>
<p class="p1">function buildStage() {</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Remove all children except the permanent floor</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>stageGroup.children.slice(1).forEach(c =&gt; stageGroup.remove(c));</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Sand/ice patches â€” capped to max 8 wide so there's always a gap to squeeze through</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const patchCount = 3 + Math.floor(rng() * 4);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>for (let i = 0; i &lt; patchCount; i++) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const w <span class="Apple-converted-space">Â  </span>= rngRange(4, 8);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const d <span class="Apple-converted-space">Â  </span>= rngRange(6, 18);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const mat = rng() &lt; 0.5 ? 'sand' : 'ice';</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const p <span class="Apple-converted-space">Â  </span>= rngPos(1);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>p.y = mat === 'sand' ? 0.05 : 0.08;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>addToStage(new THREE.BoxGeometry(w, mat === 'sand' ? 0.1 : 0.06, d), mat, { position: p });</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Ramps</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const rampCount = 2 + Math.floor(rng() * 3);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>for (let i = 0; i &lt; rampCount; i++) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const w <span class="Apple-converted-space">Â  Â  Â  </span>= rngRange(4, W * 1.5);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const d <span class="Apple-converted-space">Â  Â  Â  </span>= rngRange(6, 20);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const tiltAmt = rngRange(0.1, 0.35) * (rng() &lt; 0.5 ? 1 : -1);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const axis<span class="Apple-converted-space">Â  Â  </span>= rng() &lt; 0.5 ? E(tiltAmt, 0, 0) : E(0, 0, tiltAmt);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const p = rngPos(2); p.y = rngRange(0.5, 3);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>addToStage(new THREE.BoxGeometry(w, 0.5, d), rngItem(rampMats), { position: p, rotation: axis });</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Raised platforms</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const platCount = 1 + Math.floor(rng() * 3);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>for (let i = 0; i &lt; platCount; i++) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const w = rngRange(4, W * 1.5), d = rngRange(5, 16), h = rngRange(0.5, 3);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const p = rngPos(2); p.y = h / 2;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>addToStage(new THREE.BoxGeometry(w, h, d), rngItem(rampMats), { position: p });</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Bumper cylinders</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const bumperCount = 3 + Math.floor(rng() * 5);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>for (let i = 0; i &lt; bumperCount; i++) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const r = rngRange(0.6, 1.8), h = rngRange(1.5, 4);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const p = rngPos(2); p.y = h / 2;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>addToStage(new THREE.CylinderGeometry(r, r, h, 16), rngItem(bumperMats), { position: p });</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Box obstacles</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const boxCount = 3 + Math.floor(rng() * 4);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>for (let i = 0; i &lt; boxCount; i++) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const sz = rngRange(1.5, 4);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const p = rngPos(2); p.y = sz / 2;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>addToStage(new THREE.BoxGeometry(sz, sz, sz), rngItem(surfaceMats), { position: p });</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Cones</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const coneCount = 1 + Math.floor(rng() * 3);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>for (let i = 0; i &lt; coneCount; i++) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const r = rngRange(1.5, 3.5), h = rngRange(2, 5);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const p = rngPos(2); p.y = h / 2;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>addToStage(new THREE.ConeGeometry(r, h, 16), rngItem(rampMats), { position: p });</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Torus half-pipe (only if corridor is wide enough to make sense)</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (rng() &lt; 0.6) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const r = rngRange(2, 4);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const p = rngPos(3); p.y = rngRange(1, 3);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>addToStage(new THREE.TorusGeometry(r, rngRange(0.5, 1), 8, 24, Math.PI), rngItem(rampMats), {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>position: p,</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>rotation: E(Math.PI/2, rngRange(0, Math.PI*2), 0),</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>});</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">// â”€â”€ BALL â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</p>
<p class="p1">const ballMesh = new THREE.Mesh(</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>new THREE.SphereGeometry(BASE.radius, 32, 32),</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>new THREE.MeshStandardMaterial({ map: new THREE.TextureLoader().load('shaq.png'), roughness: 0.6, metalness: 0.1 })</p>
<p class="p1">);</p>
<p class="p1">ballMesh.castShadow = ballMesh.receiveShadow = true;</p>
<p class="p1">scene.add(ballMesh);</p>
<p class="p2"><br></p>
<p class="p1">buildStage();</p>
<p class="p1">spawnPowerups();</p>
<p class="p2"><br></p>
<p class="p1">// â”€â”€ PHYSICS STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</p>
<p class="p1">let pos<span class="Apple-converted-space">Â  Â  </span>= new THREE.Vector3(0, BASE.radius, 0);</p>
<p class="p1">let vel<span class="Apple-converted-space">Â  Â  </span>= new THREE.Vector3();</p>
<p class="p1">let angVel = new THREE.Vector3();</p>
<p class="p1">let orient = new THREE.Quaternion();</p>
<p class="p1">let onFloor = false;</p>
<p class="p1">let tiltX = 0, tiltZ = 0;</p>
<p class="p2"><br></p>
<p class="p1">// â”€â”€ CAMERA ORBIT STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</p>
<p class="p1">let camAzimuth = 0;</p>
<p class="p1">let camPolar <span class="Apple-converted-space">Â  </span>= 0.85;</p>
<p class="p1">const CAM_DIST <span class="Apple-converted-space">Â  Â  Â  </span>= 22;</p>
<p class="p1">const CAM_AZ_SPEED <span class="Apple-converted-space">Â  </span>= 1.8;</p>
<p class="p1">const CAM_POL_DEFAULT = 0.85;</p>
<p class="p1">const CAM_POL_HIGH<span class="Apple-converted-space">Â  Â  </span>= 0.15;</p>
<p class="p1">const CAM_POL_LOW <span class="Apple-converted-space">Â  Â  </span>= 1.35;</p>
<p class="p2"><br></p>
<p class="p1">// â”€â”€ INPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</p>
<p class="p1">const keys = {};</p>
<p class="p1">window.addEventListener('keydown', e =&gt; {</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>keys[e.code] = true;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (e.code === 'Space') e.preventDefault();</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (e.code === 'KeyR') reset();</p>
<p class="p1">});</p>
<p class="p1">window.addEventListener('keyup', e =&gt; { keys[e.code] = false; });</p>
<p class="p2"><br></p>
<p class="p1">function reset() {</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>pos.set(0, BASE.radius, 0); vel.set(0,0,0); angVel.set(0,0,0);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>orient.identity(); tiltX = tiltZ = 0;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>resetEffects();</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>buildStage();</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>spawnPowerups();</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">// â”€â”€ COLLISION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</p>
<p class="p1">const _A = new THREE.Vector3(), _B = new THREE.Vector3(), _C = new THREE.Vector3();</p>
<p class="p1">const _ab = new THREE.Vector3(), _ac = new THREE.Vector3();</p>
<p class="p2"><br></p>
<p class="p1">function closestPointOnTri(P, A, B, C, out) {</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>_ab.copy(B).sub(A); _ac.copy(C).sub(A);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const ap = new THREE.Vector3().copy(P).sub(A);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const d1 = _ab.dot(ap), d2 = _ac.dot(ap);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (d1 &lt;= 0 &amp;&amp; d2 &lt;= 0) { out.copy(A); return; }</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const bp = new THREE.Vector3().copy(P).sub(B);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const d3 = _ab.dot(bp), d4 = _ac.dot(bp);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (d3 &gt;= 0 &amp;&amp; d4 &lt;= d3) { out.copy(B); return; }</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const cp = new THREE.Vector3().copy(P).sub(C);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const d5 = _ab.dot(cp), d6 = _ac.dot(cp);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (d6 &gt;= 0 &amp;&amp; d5 &lt;= d6) { out.copy(C); return; }</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const vc = d1*d4 - d3*d2;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (vc &lt;= 0 &amp;&amp; d1 &gt;= 0 &amp;&amp; d3 &lt;= 0) { out.copy(A).addScaledVector(_ab, d1/(d1-d3)); return; }</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const vb = d5*d2 - d1*d6;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (vb &lt;= 0 &amp;&amp; d2 &gt;= 0 &amp;&amp; d6 &lt;= 0) { out.copy(A).addScaledVector(_ac, d2/(d2-d6)); return; }</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const va = d3*d6 - d5*d4;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (va &lt;= 0 &amp;&amp; (d4-d3) &gt;= 0 &amp;&amp; (d5-d6) &gt;= 0) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>out.copy(B).addScaledVector(new THREE.Vector3().copy(C).sub(B), (d4-d3)/((d4-d3)+(d5-d6))); return;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const f = 1/(va+vb+vc);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>out.copy(A).addScaledVector(_ab, vb*f).addScaledVector(_ac, vc*f);</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">function sphereMeshCollision(center, radius, mesh) {</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const { attributes: { position: pos }, index } = mesh.geometry;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const mw = mesh.matrixWorld;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const triCount = index ? index.count/3 : pos.count/3;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const cp = new THREE.Vector3();</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>let bestDepth = 0, bestNormal = null;</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>for (let i = 0; i &lt; triCount; i++) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const i0 = index ? index.getX(i*3) <span class="Apple-converted-space">Â  </span>: i*3;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const i1 = index ? index.getX(i*3+1) : i*3+1;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const i2 = index ? index.getX(i*3+2) : i*3+2;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>_A.fromBufferAttribute(pos, i0).applyMatrix4(mw);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>_B.fromBufferAttribute(pos, i1).applyMatrix4(mw);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>_C.fromBufferAttribute(pos, i2).applyMatrix4(mw);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>closestPointOnTri(center, _A, _B, _C, cp);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const diff = new THREE.Vector3().copy(center).sub(cp);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const dist = diff.length();</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>if (dist &gt; 1e-10 &amp;&amp; dist &lt; radius &amp;&amp; radius-dist &gt; bestDepth) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>bestDepth = radius - dist;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>bestNormal = diff.divideScalar(dist);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>return bestNormal ? { normal: bestNormal, depth: bestDepth } : null;</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">// â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€</p>
<p class="p1">const DEG = Math.PI / 180;</p>
<p class="p1">let prevTime = performance.now();</p>
<p class="p2"><br></p>
<p class="p1">function animate() {</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>requestAnimationFrame(animate);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const now = performance.now();</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const dt<span class="Apple-converted-space">Â  </span>= Math.min((now - prevTime) / 1000, 0.05);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>prevTime<span class="Apple-converted-space">Â  </span>= now;</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Tilt â€” WASD in camera-relative space</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const ts = P.tiltSpeed * DEG * dt, tr = P.tiltReturn * DEG * dt, tm = P.tiltMax * DEG;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const pX = keys['KeyW'] || keys['KeyS'];</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const pZ = keys['KeyA'] || keys['KeyD'];</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (keys['KeyW']) tiltX = Math.max(tiltX - ts, -tm);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (keys['KeyS']) tiltX = Math.min(tiltX + ts,<span class="Apple-converted-space">Â  </span>tm);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (keys['KeyA']) tiltZ = Math.min(tiltZ + ts,<span class="Apple-converted-space">Â  </span>tm);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (keys['KeyD']) tiltZ = Math.max(tiltZ - ts, -tm);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (!pX) tiltX = Math.abs(tiltX) &lt;= tr ? 0 : tiltX - Math.sign(tiltX) * tr;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (!pZ) tiltZ = Math.abs(tiltZ) &lt;= tr ? 0 : tiltZ - Math.sign(tiltZ) * tr;</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Rotate tilt vector by camera azimuth so W always tilts away from camera</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const ca = Math.cos(camAzimuth), sa = Math.sin(camAzimuth);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const worldTiltX =<span class="Apple-converted-space">Â  </span>tiltX * ca + tiltZ * sa;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const worldTiltZ = -tiltX * sa + tiltZ * ca;</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Camera orbit â€” arrow keys; up/down snap to preset polar angles</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (keys['ArrowLeft'])<span class="Apple-converted-space">Â  </span>camAzimuth += CAM_AZ_SPEED * dt;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (keys['ArrowRight']) camAzimuth -= CAM_AZ_SPEED * dt;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const targetPolar = keys['ArrowDown'] ? CAM_POL_HIGH : keys['ArrowUp'] ? CAM_POL_LOW : CAM_POL_DEFAULT;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>camPolar += (targetPolar - camPolar) * Math.min(1, 12 * dt);</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Stage pivot around ball contact point</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const stageQuat = new THREE.Quaternion().setFromEuler(new THREE.Euler(worldTiltX, 0, worldTiltZ, 'XZY'));</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const pivot = new THREE.Vector3(pos.x, 0, pos.z);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>stageGroup.position.copy(pivot).sub(pivot.clone().applyQuaternion(stageQuat));</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>stageGroup.setRotationFromQuaternion(stageQuat);</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Physics</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const grav = new THREE.Vector3(0, -P.gravity, 0);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>vel.addScaledVector(grav, dt);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>pos.addScaledVector(vel, dt);</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Jump / jetpack</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const wasOnFloor = onFloor;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (keys['Space']) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>if (onFloor) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>vel.y += currentJump; onFloor = false;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>} else if (fx.hasJetpack &amp;&amp; jetpackFuel &gt; 0) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>vel.y += JETPACK_THRUST * dt;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>jetpackFuel = Math.max(0, jetpackFuel - JETPACK_DRAIN * dt);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>updateHUD();</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Track landing moment for refill delay</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (onFloor &amp;&amp; !wasOnFloor) jetpackLandTime = now / 1000;</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Refill after 2s on ground</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (fx.hasJetpack &amp;&amp; onFloor &amp;&amp; jetpackFuel &lt; JETPACK_MAX) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>if ((now / 1000 - jetpackLandTime) &gt;= JETPACK_REFILL_DELAY) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>jetpackFuel = Math.min(JETPACK_MAX, jetpackFuel + JETPACK_REFILL_RATE * dt);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>updateHUD();</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Powerup pickup (compare world positions since powerups are in stageGroup)</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>stageGroup.updateMatrixWorld(true);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>for (let i = powerupMeshes.length - 1; i &gt;= 0; i--) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const m = powerupMeshes[i];</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const worldPos = new THREE.Vector3().setFromMatrixPosition(m.matrixWorld);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>if (pos.distanceTo(worldPos) &lt; currentRadius + 0.8) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>POWERUP_DEFS[m.userData.powerupType].onPickup();</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>stageGroup.remove(m);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>powerupMeshes.splice(i, 1);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>updateHUD();</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Bob powerup meshes in local stage space</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>powerupMeshes.forEach((m, idx) =&gt; {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>m.position.y = 1.5 + Math.sin(now * 0.002 + idx * 1.3) * 0.3;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>m.rotation.y += dt * 1.5;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>});</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Collision</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>stageGroup.updateMatrixWorld(true);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>onFloor = false;</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>stageGroup.traverse(child =&gt; {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>if (!child.isMesh || child.userData.collidable === false) return;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const hit = sphereMeshCollision(pos, currentRadius, child);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>if (!hit) return;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const { normal: n, depth } = hit;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const phys = MATERIALS[child.userData.physicsMaterial] || MATERIALS.default;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const restitution = Math.min(phys.restitution * bouncyMult, 0.99);</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>pos.addScaledVector(n, depth);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const vn = vel.dot(n);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>if (vn &lt; 0) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>vel.addScaledVector(n, -vn * (1 + restitution));</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>if (vel.dot(n) &lt; 0.4) vel.addScaledVector(n, -vel.dot(n));</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>onFloor = true;</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>// Friction</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const r = n.clone().multiplyScalar(-currentRadius);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const vSlip = vel.clone().add(new THREE.Vector3().crossVectors(angVel, r))</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>.addScaledVector(n, -vel.clone().add(new THREE.Vector3().crossVectors(angVel, r)).dot(n));</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const slipSpeed = vSlip.length();</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>if (slipSpeed &gt; 1e-5) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>const I_cur = 0.4 * P.mass * currentRadius * currentRadius;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>const sd <span class="Apple-converted-space">Â  </span>= vSlip.clone().divideScalar(slipSpeed);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>const Fn <span class="Apple-converted-space">Â  </span>= P.mass * Math.abs(grav.dot(n));</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>const mEff = 1 / (1/P.mass + new THREE.Vector3().crossVectors(r, sd).lengthSq() / I_cur);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>const imp<span class="Apple-converted-space">Â  </span>= sd.multiplyScalar(-Math.min(slipSpeed * mEff, phys.friction * Fn * dt));</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>vel.addScaledVector(imp, 1/P.mass);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>angVel.addScaledVector(new THREE.Vector3().crossVectors(r, imp), 1/I_cur);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>}</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>// Rolling resistance</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const I_cur2 = 0.4 * P.mass * currentRadius * currentRadius;</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>const wSpeed = angVel.length();</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>if (wSpeed &gt; 1e-6) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>const dw = Math.min(phys.rollingResist * P.mass * Math.abs(grav.dot(n)) * currentRadius * dt / I_cur2, wSpeed);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  Â  </span>angVel.multiplyScalar(1 - dw / wSpeed);</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>}</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>});</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (pos.y &lt; -15) { reset(); return; }</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Orientation</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const wLen = angVel.length();</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>if (wLen &gt; 1e-10) {</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>orient.premultiply(new THREE.Quaternion().setFromAxisAngle(angVel.clone().divideScalar(wLen), wLen * dt));</p>
<p class="p1"><span class="Apple-converted-space">Â  Â  </span>orient.normalize();</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>}</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Update meshes &amp; camera</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>ballMesh.position.copy(pos);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>ballMesh.setRotationFromQuaternion(orient);</p>
<p class="p2"><br></p>
<p class="p1"><span class="Apple-converted-space">Â  </span>// Spherical orbit camera around ball</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const camX = pos.x + CAM_DIST * Math.sin(camPolar) * Math.sin(camAzimuth);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const camY = pos.y + CAM_DIST * Math.cos(camPolar);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>const camZ = pos.z + CAM_DIST * Math.sin(camPolar) * Math.cos(camAzimuth);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>camera.position.lerp(new THREE.Vector3(camX, camY, camZ), 0.08);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>camera.lookAt(pos);</p>
<p class="p1"><span class="Apple-converted-space">Â  </span>renderer.render(scene, camera);</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">animate();</p>
<p class="p1">&lt;/script&gt;</p>
<p class="p1">&lt;/body&gt;</p>
<p class="p1">&lt;/html&gt;</p>
</body>
</html>
